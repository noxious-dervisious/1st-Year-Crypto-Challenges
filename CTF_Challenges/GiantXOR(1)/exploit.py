from __future__ import print_function
from string import *
from predict_keylength import key_length
from base64 import *

base64string = ascii_lowercase + ascii_uppercase + digits + "+/=" + "\n"
possibles = printable

def reapeting_key_xor (plaintext,key) :
	index= 0
	ciphertext = '' 
	for ch in plaintext:
		ciphertext += str(chr(ord(ch) ^ ord(key[index])))
		if index + 1 == len(key):
			index=0
		else :
			index += 1
	return ciphertext

def singleXOR(ciphertext,keychar):
	res = ""
	for i in ciphertext:
		out = chr(ord(i) ^ ord(keychar)) 
		if out in base64string:
			res += out
		else: 
			keychar = "*"
			break
	return keychar

def exploit():
	ciphertext = open('ciphertext.txt').read().strip()
	ciphertext = ciphertext.decode('hex')
	keylength = key_length(ciphertext)
	key = ""
	blockmade = []
	cod = ""
	for i in range (keylength): 
		cod = ""
		for j in range(i,len(ciphertext)-1,keylength):
			cod += ciphertext[j]
		blockmade.append(cod)
	for block in blockmade: 
		for keychar in possibles:
			approx = singleXOR(block,keychar)
			if approx != '*':
				key += approx
				break
	print("The key : {} ".format(key))
	plaintext = b64decode(reapeting_key_xor(ciphertext,key)) 
	print("The plain text : \n ",plaintext)


exploit()